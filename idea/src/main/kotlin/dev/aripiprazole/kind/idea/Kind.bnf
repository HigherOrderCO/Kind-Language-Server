{
  parserClass="dev.aripiprazole.kind.idea.parser.KindParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Kind"
  psiImplClassSuffix="Impl"
  psiPackage="dev.aripiprazole.kind.idea.psi"
  psiImplPackage="dev.aripiprazole.kind.idea.psi.impl"

  elementTypeHolderClass="dev.aripiprazole.kind.idea.KindTypes"
  elementTypeClass="dev.aripiprazole.kind.idea.KindElementType"
  tokenTypeClass="dev.aripiprazole.kind.idea.KindTokenType"
  
  psiImplUtilClass="dev.aripiprazole.kind.idea.psi.KindPsiImplUtil"
}

simpleFile ::= declaration* EOF;
eol ::= (SEMI | CRLF)*;

declaration ::= SEMI | CRLF | DOC_STRING | COMMENT | attribute eol | type_declaration eol | use_declaration eol | rule_declaration eol | val_declaration eol;

attribute ::= HASHTAG attribute_name (attribute_argument | attribute_assign)?;

attribute_name ::= any_name;

attribute_argument ::= LEFT_BRACKET any_name (COMMA any_name)* RIGHT_BRACKET;

attribute_assign ::= EQUAL any_name;

type_declaration ::= (type_keyword | record_keyword) type_name parameter* LEFT_BRACE (declaration | type_val_declaration eol)* RIGHT_BRACE;

use_declaration ::= use_keyword any_name as_keyword any_name;

val_declaration ::= any_name parameter* return_type? rule_block_value?;

type_val_declaration ::= rule_name parameter* return_type?;

rule_name ::= any_name;

any_name ::= val_name | local_name;

any_identifier ::= identifier | qualified | number_primary;

val_name ::= qualified (DOT any_identifier)*;

local_name ::= identifier (DOT any_identifier)*;

type_name ::= val_name | local_name;

parameter_name ::= val_name | local_name;

return_type ::= COLON type_expr;

parameter ::= explicit_parameter | implicit_parameter | TILDE;

explicit_parameter ::= LEFT_PAREN parameter_name (COLON type_expr)? RIGHT_PAREN;

implicit_parameter ::= LT parameter_name (COLON type_expr)? GT;

deconstruct_pattern ::= LEFT_PAREN parameter_name rule_pattern* RIGHT_PAREN;

at_pattern ::= LEFT_PAREN parameter_name AT rule_pattern RIGHT_PAREN;

rule_pattern ::= STRING_LITERAL 
               | NAT_LITERAL
               | F60_LITERAL
               | U60_LITERAL
               | U120_LITERAL
               | CHAR_LITERAL
               | at_pattern
               | deconstruct_pattern
               | local_name
               | some_name
               ;

rule_declaration ::= any_name rule_pattern* (rule_value | rule_block_value);

rule_block_value ::= LEFT_BRACE statement* RIGHT_BRACE;

rule_value ::= EQUAL statement;

statement ::= comments* statement_;

private statement_ ::= let_stmt | open_stmt | ask_stmt | return_stmt | expr eol;

comments ::= DOC_STRING | COMMENT;

let_stmt ::= let_keyword any_name EQUAL expr let_in?;

let_in ::= eol statement;

open_stmt ::= open_keyword any_name any_name open_in?;

open_in ::= eol statement;

ask_stmt ::= ask_keyword any_name EQUAL? expr eol;

return_stmt ::= return_keyword expr eol;

type_expr ::= expr;

expr ::= DOC_STRING | COMMENT | match_expr | if_expr | do_expr | lam_typed_expr | lam_expr;

lam_typed_expr ::= (LEFT_PAREN any_name COLON type_expr RIGHT_PAREN) ((ARROW | FAT_ARROW) expr)?;

lam_expr ::= call (binary expr)?;

if_expr ::= if_keyword expr then_expr else_expr?;

block ::= LEFT_BRACE statement* RIGHT_BRACE;

then_expr ::= block;

else_expr ::= else_keyword block;

do_expr ::= do_keyword type_name? block;

match_pattern ::= any_name | deconstruct_pattern;

match_case ::= match_pattern FAT_ARROW (block | expr);

scrutinee ::= any_name EQUAL expr | expr;

match_expr ::= match_keyword type_name? scrutinee LEFT_BRACE match_case* RIGHT_BRACE;

identifier ::= ATOM {
  methods="getIdentifier"
};

qualified ::= CONSTRUCTOR {
  methods="getIdentifier"
};

call ::= unary (get_arguments | call_arguments)*;

call_arguments ::= LEFT_PAREN any_name EQUAL expr RIGHT_PAREN | primary;
get_arguments ::= DOT (identifier | qualified | number_primary);

unary ::= primary
        | HELP_TOKEN
        | LEFT_PAREN UNARY_OP RIGHT_PAREN primary
        ;

primary ::= STRING_LITERAL 
          | CHAR_LITERAL
          | LEFT_PAREN expr RIGHT_PAREN
          | number_primary
          | identifier
          | some_name
          ;
          
private number_primary ::= NAT_LITERAL
                         | F60_LITERAL
                         | U60_LITERAL
                         | U120_LITERAL
                         ;
          
some_name ::= predefined_name | val_name;

predefined_name ::= 'Bool.true' | 'Bool.false' | 'Bool.if' | 'List' | 'Unit' | 'Unit.new';

type_keyword ::= 'type';
record_keyword ::= 'record';
use_keyword ::= 'use';
let_keyword ::= 'let';
do_keyword ::= 'do';
ask_keyword ::= 'ask';
as_keyword ::= 'as';
return_keyword ::= 'return';
open_keyword ::= 'open';
match_keyword ::= 'match';
constructor_keyword ::= 'constructor';
if_keyword ::= 'if';
else_keyword ::= 'else';
with_keyword ::= 'with';
specialize_keyword ::= 'specialize';
into_keyword ::= 'into';

binary ::= ARROW | FAT_ARROW | COLON_COLON;
